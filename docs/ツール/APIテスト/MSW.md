# MSW (Mock Service Worker)

## 概要

MSW は、ブラウザと Node.js の通信をインターセプトして API モックを返す JavaScript/TypeScript 向けツールである。開発時とテスト時で同じハンドラーを使い回せるため、フロントエンド開発のモック運用を一元化しやすい。

## 料金

| プラン | 内容 |
|------|------|
| OSS 版 | 無料（MIT License） |
| 商用利用 | ライセンス上可能（組織ポリシー確認は必要） |

## 主な特徴

| 項目 | 内容 |
|------|------|
| 非侵襲的モック | アプリ本体の API 実装を差し替えずに利用可能 |
| ブラウザ/Node 両対応 | 開発環境とテスト環境で同じ定義を再利用 |
| REST/GraphQL 対応 | HTTP API と GraphQL API を同一流儀でモック化 |
| TypeScript フレンドリー | 型付きハンドラーで保守しやすい |
| テスト統合 | Jest/Vitest/Playwright などに組み込みやすい |

## 主な機能

### リクエストハンドリング機能

| 機能 | 説明 |
|------|------|
| REST ハンドラー | `http.get/post/...` でエンドポイントを定義 |
| GraphQL ハンドラー | `graphql.query/mutation` で操作単位にモック |
| パラメータ処理 | パス、クエリ、ヘッダー、Cookie を参照可能 |
| 動的レスポンス | リクエスト内容に応じてレスポンスを分岐 |

### テスト支援機能

| 機能 | 説明 |
|------|------|
| ハンドラー上書き | テスト単位で一時的なレスポンス差し替え |
| 遅延/エラー再現 | `delay` や `HttpResponse.error()` で障害系を再現 |
| 未定義 API 検知 | `onUnhandledRequest` で漏れを可視化 |
| 共通セットアップ | `beforeAll/afterEach/afterAll` で定型運用 |

### 運用機能

| 機能 | 説明 |
|------|------|
| ハンドラー分割 | ドメイン単位で管理して拡張しやすい |
| 開発環境制御 | 環境変数で有効/無効を切替 |
| Storybook 連携 | コンポーネント単体検証に活用可能 |
| E2E 連携 | 実 API 依存を減らしてテスト安定化 |

## インストールとセットアップ

公式URL:
- [MSW 公式サイト](https://mswjs.io/)
- [MSW ドキュメント](https://mswjs.io/docs/)
- [MSW GitHub](https://github.com/mswjs/msw)
- [MSW Examples](https://github.com/mswjs/examples)

セットアップの要点:
1. 開発プロジェクトに `msw` を開発依存として追加する。
2. ブラウザ利用時は `msw init` で Service Worker を生成する。
3. `handlers`、`browser`、`server` の3ファイルに役割分離して管理する。

## 基本的な使い方

1. API ごとにハンドラーを定義し、正常系と異常系の返却パターンを用意する。
2. 開発環境では `setupWorker` を起動し、未定義リクエストを警告する設定にする。
3. テスト環境では `setupServer` を使い、テスト前後でハンドラーを初期化する。
4. テストケースごとに必要なハンドラーだけ上書きして差分検証する。

最小コマンド:
- Service Worker 生成: `npx msw init public/ --save`

## メリット

- 開発とテストで同一モックを使えるため二重管理を避けやすい
- UI 実装をバックエンド実装と並行で進めやすい
- 失敗系・遅延系シナリオを簡単に再現できる
- TypeScript と相性が良く保守しやすい

## デメリット

- JavaScript/TypeScript プロジェクト向けで他言語には直接使いにくい
- Service Worker の理解が必要で初期学習コストがある
- 大規模モックではハンドラー設計ルールがないと肥大化しやすい

## 他ツールとの比較

| ツール | 主な対象 | 特徴 |
|------|------|------|
| MSW | フロントエンド開発/テスト | ブラウザ/Node で同じハンドラーを再利用 |
| MockServer | API 契約テスト/結合テスト | OpenAPI 連携と検証 API が強い |
| WireMock | HTTP モック全般 | 採用実績が多くスタンドアロン運用しやすい |
| Nock | Node.js ユニットテスト | 軽量で Node 内の HTTP モックに特化 |

## ベストプラクティス

### 1. ハンドラーをドメイン単位で分割

- `userHandlers`、`orderHandlers` のように責務別に整理する
- `index.ts` で統合して起動点を一つにする

### 2. 環境別に振る舞いを切り替える

- 開発は `warn`、CI は `error` で未定義 API の扱いを変える
- ステージングでは必要最小限だけモック化する

### 3. エラーケースを先に整備

- 401、404、500、タイムアウトの標準ハンドラーを用意する
- UI の例外表示を早期に固める

## 公式ドキュメント

- 公式サイト: https://mswjs.io/
- ドキュメント: https://mswjs.io/docs/
- API リファレンス: https://mswjs.io/docs/api
- GitHub: https://github.com/mswjs/msw

## まとめ

1. **資産共通** : ブラウザと Node で同じハンドラーを使えるため、開発とテストのモック資産を共通化できる。
2. **並行開発** : 実 API 未完成でも UI 開発を先行でき、フロントエンド実装の待ち時間を減らせる。
3. **安定検証** : 未定義 API 検知やエラーケース整備により、回帰テストの安定性を高めやすい。
