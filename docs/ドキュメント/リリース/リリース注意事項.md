# リリース時の注意事項・ベストプラクティス

## ドキュメント情報

このドキュメントは、リリース作業を安全かつ効率的に実施するための注意事項、ベストプラクティス、よくある失敗事例をまとめたものです。

---

## 目次

1. [リリース前の心構え](#1-リリース前の心構え)
2. [リリース手順書作成の原則](#2-リリース手順書作成の原則)
3. [リリース作業の鉄則](#3-リリース作業の鉄則)
4. [よくある失敗事例と対策](#4-よくある失敗事例と対策)
5. [切り戻し判断のガイドライン](#5-切り戻し判断のガイドライン)
6. [コミュニケーションのベストプラクティス](#6-コミュニケーションのベストプラクティス)
7. [データベース変更時の注意事項](#7-データベース変更時の注意事項)
8. [監視・ログ確認のポイント](#8-監視ログ確認のポイント)
9. [チェックリスト活用法](#9-チェックリスト活用法)
10. [リリース後の振り返り](#10-リリース後の振り返り)

---

## 1. リリース前の心構え

### 1.1 リリースは「戦い」ではなく「計画的な作業」

❌ **NG**: 「リリースは何が起こるか分からない」と考える
✅ **OK**: 「リリースは計画に基づいて実施する作業」と考える

**理由**: 不確実性を受け入れるのではなく、計画によって不確実性を最小化する

### 1.2 「失敗しても大丈夫」な準備をする

✅ **必須の準備**:
- バックアップが確実に取得されている
- 切り戻し手順が確認されている
- 制限時間内に切り戻せる自信がある

### 1.3 「思考停止でもリリースが完了する」レベルを目指す

リリース当日は緊張や疲労で判断力が低下します。そのため:

- コピー＆ペーストで実行できるコマンド
- YesNoで判断できる確認項目
- 迷わない意思決定フロー

を準備することが重要です。

---

## 2. リリース手順書作成の原則

### 2.1 5つの基本原則

#### 1. **変化前の確認 ⇒ 変化 ⇒ 変化後の確認**

```markdown
# ❌ NG例
1. アプリケーションをデプロイする

# ✅ OK例
1. 【変化前】現在のバージョンを確認する
   ```bash
   kubectl get deployment app -o jsonpath='{.spec.template.spec.containers[0].image}'
   ```
   期待値: `app:v1.1.0`

2. 【変化】新バージョンをデプロイする
   ```bash
   kubectl set image deployment/app app=app:v1.2.0
   ```

3. 【変化後】バージョンが変更されたことを確認する
   ```bash
   kubectl get deployment app -o jsonpath='{.spec.template.spec.containers[0].image}'
   ```
   期待値: `app:v1.2.0`
```

#### 2. **上から下までコピペでリリースできる**

❌ **NG**: 「適宜コマンドを修正してください」
✅ **OK**: そのままコピー＆ペーストで実行できるコマンド

```bash
# ❌ NG例
DATABASE_URL=<接続文字列を入力> bundle exec rails db:migrate

# ✅ OK例（環境変数を事前設定）
export DATABASE_URL="postgresql://user:password@localhost:5432/production"
bundle exec rails db:migrate
```

#### 3. **読者（実施者）がいることを意識する**

リリース手順書の読者は:
- 深夜の疲労状態
- プレッシャーを感じている
- 判断力が低下している

可能性があります。そのため:
- 難しい専門用語を避ける
- 判断基準を明確にする
- スクリーンショットを活用する

#### 4. **相手を思いやって書く**

❌ **NG**: 「○○を実施してください（詳細は省略）」
✅ **OK**: 「○○を実施してください。この作業の目的は△△です。所要時間は約5分です。」

#### 5. **意図を持って書く**

各ステップに「なぜこの作業が必要なのか」を記載する

```markdown
# ✅ OK例
## データベースバックアップ取得

**目的**: 万が一マイグレーションに失敗した場合に、データを復元するため
**所要時間**: 約10分
**注意事項**: バックアップ完了まで次のステップに進まないこと

```bash
pg_dump -Fc production > backup_$(date +%Y%m%d_%H%M%S).dump
```
```

### 2.2 属人化を防ぐ

#### Markdown + Git管理のメリット

| 従来（Excel） | Markdown + Git |
|-------------|----------------|
| ファイルが散在する | リポジトリで一元管理 |
| バージョン管理が困難 | Gitで履歴管理 |
| 差分確認が手間 | Pull Requestで差分自動表示 |
| 検索が難しい | grep/GitHub Searchで検索容易 |
| 2ヶ月で所在不明 | 永続的にアクセス可能 |

#### テンプレート化の推奨

```markdown
# テンプレート構造例

templates/
  ├── release_plan_template.md        # リリース計画テンプレート
  ├── release_procedure_template.md   # リリース手順テンプレート
  └── rollback_procedure_template.md  # 切り戻し手順テンプレート

releases/
  ├── 2025-01-25_v1.2.0/
  │   ├── release_plan.md
  │   ├── release_procedure.md
  │   └── rollback_procedure.md
  └── 2025-02-15_v1.3.0/
      ├── release_plan.md
      ├── release_procedure.md
      └── rollback_procedure.md
```

---

## 3. リリース作業の鉄則

### 3.1 時間管理の鉄則

#### ⏰ **制限時間を設定する**

| フェーズ | 制限時間 | 超過時の対応 |
|---------|---------|------------|
| リリース作業全体 | 2時間 | 切り戻し検討 |
| データベースマイグレーション | 30分 | 即座に切り戻し |
| 動作確認 | 30分 | Go/No-Go判断 |

#### ⏱️ **定期的な進捗報告**

```markdown
# 15分ごとに進捗報告

20:00 [開始] リリース作業を開始します
20:15 [進行中] データベースバックアップ完了（1/5）
20:30 [進行中] アプリケーションデプロイ完了（2/5）
20:45 [進行中] DBマイグレーション完了（3/5）
21:00 [完了] リリース作業完了
```

### 3.2 バックアップの鉄則

#### 📦 **バックアップは必ず取得・検証する**

```bash
# ❌ NG: バックアップ取得だけ
pg_dump production > backup.dump

# ✅ OK: バックアップ取得 + 検証
# 1. バックアップ取得
pg_dump -Fc production > backup_$(date +%Y%m%d_%H%M%S).dump

# 2. ファイルサイズ確認
ls -lh backup_*.dump

# 3. バックアップの整合性確認
pg_restore --list backup_*.dump | head -20

# 4. （可能なら）テスト環境で復元テスト
```

### 3.3 確認の鉄則

#### ✅ **目視確認 + 自動確認**

```markdown
# ❌ NG: 主観的な確認
「画面を見て正常そうだったのでOK」

# ✅ OK: 客観的な確認
1. ヘルスチェックエンドポイントが200を返すこと
   ```bash
   curl -f https://api.example.com/health
   ```
2. エラーログに "ERROR" が含まれないこと
   ```bash
   kubectl logs -l app=api --tail=100 | grep ERROR
   ```
3. レスポンスタイムが3秒以内であること
   ```bash
   time curl https://api.example.com/users/1
   ```
```

---

## 4. よくある失敗事例と対策

### 4.1 データベース関連

#### ❌ 失敗例1: マイグレーションのロールバックができない

**原因**: 破壊的変更（カラム削除、テーブル削除）のロールバックスクリプトがない

**対策**:
```ruby
# ✅ OK: 双方向マイグレーション
class AddEmailToUsers < ActiveRecord::Migration[7.0]
  def up
    add_column :users, :email, :string
  end

  def down
    remove_column :users, :email
  end
end
```

#### ❌ 失敗例2: マイグレーション中にタイムアウト

**原因**: 大量データへのカラム追加をロック取得して実行

**対策**:
```sql
-- ❌ NG: ロック取得（テーブル全体がロックされる）
ALTER TABLE users ADD COLUMN status VARCHAR(20);

-- ✅ OK: ロックを取得しない方法
ALTER TABLE users ADD COLUMN status VARCHAR(20) DEFAULT 'active' NOT NULL;
-- PostgreSQLの場合
ALTER TABLE users ADD COLUMN status VARCHAR(20);
-- インデックス作成もCONCURRENTLYで
CREATE INDEX CONCURRENTLY idx_users_status ON users(status);
```

### 4.2 デプロイ関連

#### ❌ 失敗例3: 新旧バージョンが混在してエラー

**原因**: Blue-Greenデプロイせず、ローリングアップデートで互換性のない変更を実施

**対策**:
- APIのバージョニング
- 後方互換性のある変更
- Blue-Greenデプロイ採用

#### ❌ 失敗例4: 環境変数の設定漏れ

**原因**: 新機能で追加した環境変数を本番環境に設定し忘れ

**対策**:
```bash
# ✅ OK: 環境変数チェックスクリプト
#!/bin/bash
required_vars=("DATABASE_URL" "SECRET_KEY" "API_TOKEN")

for var in "${required_vars[@]}"; do
  if [ -z "${!var}" ]; then
    echo "❌ ERROR: $var is not set"
    exit 1
  fi
done

echo "✅ All required environment variables are set"
```

### 4.3 監視関連

#### ❌ 失敗例5: リリース後の監視を怠る

**原因**: リリース完了後すぐに帰宅し、深夜にエラーが多発

**対策**:
- リリース後24時間は監視を強化
- アラート閾値を一時的に厳しく設定
- オンコール体制の確保

---

## 5. 切り戻し判断のガイドライン

### 5.1 即座に切り戻すべき状況

以下のいずれかに該当する場合、**議論せず即座に切り戻し**:

- [ ] アプリケーションが起動しない
- [ ] ログイン機能が動作しない
- [ ] 決済機能が動作しない
- [ ] データ損失が発生している
- [ ] セキュリティインシデントが発生している

### 5.2 切り戻しを検討すべき状況

以下の場合、**リリース責任者が切り戻しを判断**:

- [ ] エラーレートが通常の10倍を超えている
- [ ] レスポンスタイムが通常の3倍を超えている
- [ ] 主要機能の一部が動作しない
- [ ] ユーザーからのクレームが急増している

### 5.3 切り戻さず対応できる状況

以下の場合、**Hotfixで対応**:

- [ ] マイナーな機能の不具合
- [ ] UIの表示崩れ
- [ ] 軽微なパフォーマンス劣化
- [ ] すぐに修正可能な不具合

### 5.4 切り戻し判断フローチャート

```mermaid
flowchart TD
    A[障害検知] --> B{ユーザー影響あり?}
    B -->|なし| C[監視継続]
    B -->|あり| D{クリティカル?<br/>ログイン/決済/データ損失}
    D -->|Yes| E[即座に切り戻し]
    D -->|No| F{エラーレート10倍超?<br/>またはレスポンス3倍超?}
    F -->|Yes| G{制限時間内?<br/>リリースから2時間以内}
    F -->|No| H{Hotfix可能?}
    G -->|No| E
    G -->|Yes| I[リリース責任者判断]
    H -->|Yes| J[Hotfix適用]
    H -->|No| E
    I -->|切り戻し| E
    I -->|継続| J
```

---

## 6. コミュニケーションのベストプラクティス

### 6.1 リリース当日のコミュニケーション原則

#### 📢 **報告は簡潔・明確に**

❌ **NG**:
```
「なんか遅い気がするんですけど、これって大丈夫ですかね？」
```

✅ **OK**:
```
【異常検知】レスポンスタイム平均 5.2秒（通常1.5秒）
確認中です。2分後に再報告します。
```

#### ⚡ **緊急度を明示する**

```markdown
# テンプレート

【通常】進捗報告：○○完了（X/Y）
【注意】警告：○○で△△が発生。対応中
【緊急】障害発生：○○が停止。切り戻し検討中
【解決】復旧完了：○○が正常化
```

### 6.2 事前告知のベストプラクティス

#### 📅 **告知タイミング**

| 対象 | 告知タイミング | チャネル |
|------|--------------|---------|
| 全ユーザー | 3日前 | アプリ内通知・メール |
| VIPユーザー | 1週間前 | 個別メール・電話 |
| 社内関係者 | 1週間前 | Slack・メール |

#### 📝 **告知文例**

```markdown
【メンテナンスのお知らせ】

平素より○○サービスをご利用いただき、ありがとうございます。

下記の日程でメンテナンスを実施いたします。

■ メンテナンス日時
2025年1月25日（土）21:00 〜 23:00（予定）

■ 影響範囲
- サービスが一時的にご利用いただけなくなります
- メンテナンス中のデータは保存されません

■ 実施内容
- 新機能「○○」の追加
- パフォーマンス改善
- セキュリティアップデート

ご不便をおかけいたしますが、何卒ご理解のほどよろしくお願いいたします。
```

---

## 7. データベース変更時の注意事項

### 7.1 破壊的変更を避ける

#### ❌ **破壊的変更（避けるべき）**

- カラムの削除
- テーブルの削除
- データ型の変更（文字列→数値等）
- NOT NULL制約の追加（既存データがNULLの場合）

#### ✅ **非破壊的変更（推奨）**

- カラムの追加（NULL許可 or DEFAULT値あり）
- テーブルの追加
- インデックスの追加（CONCURRENTLY）

### 7.2 段階的リリースパターン

**破壊的変更が必要な場合の対応**:

```markdown
# Phase 1: カラム追加（新旧両対応）
- 新カラム `email_v2` を追加
- アプリケーションを新旧両対応に変更
- リリース・動作確認

# Phase 2: データ移行
- 旧カラム `email` から新カラム `email_v2` へデータ移行
- 検証

# Phase 3: 旧カラム削除（数週間後）
- アプリケーションを新カラムのみに変更
- リリース・動作確認
- 旧カラム `email` を削除
```

### 7.3 大量データ変更時の注意

```sql
-- ❌ NG: 一括更新（ロック時間長い）
UPDATE users SET status = 'active' WHERE status IS NULL;

-- ✅ OK: バッチ更新（ロック時間短い）
-- 1000件ずつ更新
DO $$
DECLARE
  batch_size INT := 1000;
  affected_rows INT;
BEGIN
  LOOP
    UPDATE users
    SET status = 'active'
    WHERE id IN (
      SELECT id FROM users
      WHERE status IS NULL
      LIMIT batch_size
    );

    GET DIAGNOSTICS affected_rows = ROW_COUNT;
    EXIT WHEN affected_rows = 0;

    -- 他のトランザクションを待たせないため
    COMMIT;
    -- 負荷分散のため
    PERFORM pg_sleep(1);
  END LOOP;
END $$;
```

---

## 8. 監視・ログ確認のポイント

### 8.1 リリース後の監視チェックリスト

#### 即座に確認（リリース直後）

- [ ] アプリケーションログにERRORがないか
- [ ] HTTPステータスコード 5xx の発生率
- [ ] レスポンスタイム（p50, p95, p99）
- [ ] CPU・メモリ使用率
- [ ] データベース接続数

#### 15分後に確認

- [ ] エラーレートの推移
- [ ] ユーザーからの問い合わせ
- [ ] 外部サービスとの連携状況

#### 24時間後に確認

- [ ] 日次バッチ処理の成功
- [ ] データ整合性
- [ ] パフォーマンス指標の安定性

### 8.2 アラート設定の推奨

```yaml
# 推奨アラート設定例

alerts:
  # クリティカル（即座に対応）
  - name: application_down
    condition: health_check_failure > 0
    severity: critical
    notification: phone + slack

  - name: high_error_rate
    condition: error_rate > 10%
    severity: critical
    notification: phone + slack

  # 警告（監視強化）
  - name: slow_response
    condition: response_time_p95 > 3s
    severity: warning
    notification: slack

  - name: high_cpu
    condition: cpu_usage > 80%
    severity: warning
    notification: slack
```

---

## 9. チェックリスト活用法

### 9.1 チェックリストの原則

#### ✅ **良いチェックリスト**

- [ ] 1項目 = 1アクション
- [ ] Yes/Noで判断できる
- [ ] 実施者と期限が明確
- [ ] 依存関係が明確

#### ❌ **悪いチェックリスト**

- [ ] 「適切に○○を実施する」（曖昧）
- [ ] 「○○と△△を実施する」（複数アクション）
- [ ] 担当者不明

### 9.2 チェックリストテンプレート

```markdown
## リリース前チェックリスト

| # | 項目 | 期限 | 担当者 | 完了 | 備考 |
|---|------|------|--------|------|------|
| 1 | コードレビュー完了 | D-7 | 開発リーダー | [ ] | - |
| 2 | ステージング環境テスト完了 | D-3 | QA | [ ] | - |
| 3 | データベースバックアップ取得 | D-0 20:00 | DBA | [ ] | 10分程度 |
| 4 | メンテナンス告知掲示 | D-0 19:00 | 運用 | [ ] | - |
```

---

## 10. リリース後の振り返り

### 10.1 振り返り会議のアジェンダ

**開催タイミング**: リリースから3営業日以内

#### 1. リリース結果の確認（10分）

- リリースは成功したか？
- 発生した問題は何か？
- ユーザー影響はあったか？

#### 2. KPI達成状況（10分）

| 指標 | 目標 | 実績 | 評価 |
|------|------|------|------|
| リリース時間 | 2時間以内 | 1.5時間 | ✅ |
| エラー発生率 | 0.1%以下 | 0.05% | ✅ |
| 切り戻し回数 | 0回 | 0回 | ✅ |
| ユーザークレーム | 0件 | 1件 | ⚠️ |

#### 3. 良かった点（Keep）（10分）

- チェックリストが詳細で迷わなかった
- 切り戻し手順が明確だった

#### 4. 改善点（Problem）（15分）

- データベースマイグレーションに予想以上の時間がかかった
- 監視ダッシュボードが見づらかった

#### 5. アクションアイテム（Try）（15分）

| # | 改善項目 | 担当者 | 期限 | チケット |
|---|---------|--------|------|---------|
| 1 | マイグレーション所要時間の事前計測 | DBA | 次回リリースまで | TASK-123 |
| 2 | 監視ダッシュボードの改善 | インフラ | 2週間以内 | TASK-124 |

### 10.2 ドキュメント改善

振り返りで出た改善点を**即座にドキュメントに反映**:

```bash
# 1. リリース手順書を更新
git checkout -b improve/release-procedure
vim docs/release/release_procedure_vX.X.X.md

# 2. コミット
git add docs/release/
git commit -m "docs: リリース手順書を改善

- マイグレーション所要時間の事前計測手順を追加
- 監視ダッシュボード確認手順を明確化"

# 3. Pull Request作成
git push origin improve/release-procedure
gh pr create --title "リリース手順書の改善" --body "振り返り会議での改善点を反映"
```

---

## 付録: 便利なスクリプト・ツール

### A. リリース前チェックスクリプト

```bash
#!/bin/bash
# pre_release_check.sh

echo "🔍 リリース前チェックを開始します..."

# 環境変数チェック
echo "1. 環境変数チェック..."
required_vars=("DATABASE_URL" "SECRET_KEY" "API_TOKEN")
for var in "${required_vars[@]}"; do
  if [ -z "${!var}" ]; then
    echo "❌ ERROR: $var is not set"
    exit 1
  fi
done
echo "✅ 環境変数OK"

# Gitブランチチェック
echo "2. Gitブランチチェック..."
current_branch=$(git rev-parse --abbrev-ref HEAD)
if [ "$current_branch" != "main" ]; then
  echo "❌ ERROR: 現在のブランチは $current_branch です。mainブランチでリリースしてください"
  exit 1
fi
echo "✅ ブランチOK"

# 未コミットの変更チェック
echo "3. 未コミット変更チェック..."
if ! git diff-index --quiet HEAD --; then
  echo "❌ ERROR: 未コミットの変更があります"
  git status
  exit 1
fi
echo "✅ 未コミット変更なし"

# テスト実行
echo "4. テスト実行..."
if ! npm test; then
  echo "❌ ERROR: テストが失敗しました"
  exit 1
fi
echo "✅ テストOK"

echo "✅ すべてのチェックに合格しました。リリース可能です。"
```

### B. ヘルスチェックスクリプト

```bash
#!/bin/bash
# health_check.sh

API_URL="https://api.example.com"

# ヘルスチェック
response=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/health")
if [ "$response" != "200" ]; then
  echo "❌ ヘルスチェック失敗: HTTP $response"
  exit 1
fi

# レスポンスタイム確認
response_time=$(curl -s -o /dev/null -w "%{time_total}" "$API_URL/users/1")
if (( $(echo "$response_time > 3.0" | bc -l) )); then
  echo "⚠️ 警告: レスポンスタイムが遅い ($response_time 秒)"
fi

echo "✅ ヘルスチェックOK"
```

---

## まとめ

### リリース成功の3つの鍵

1. **計画**: 詳細なリリース計画と切り戻し計画
2. **確認**: 変化前・変化・変化後の3段階確認
3. **改善**: 振り返りによる継続的改善

### 最も重要なこと

> **「切り戻し計画」が最も重要**
>
> 何か問題が発生した時、確実に元の状態に戻せることが、
> 安全なリリースの基本です。

---

**最終更新日**: 2025年12月
**ドキュメントバージョン**: 1.0
