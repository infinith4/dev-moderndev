# 詳解リリース計画 - 実践ガイド

## はじめに

このドキュメントは、リリース計画の立て方から実施、振り返りまでの全プロセスを詳細に解説した実践ガイドです。参照URLの知見を統合し、具体例を豊富に含めています。

---

## 目次

1. [リリース計画の全体像](#1-リリース計画の全体像)
2. [リリース計画の立て方（詳細）](#2-リリース計画の立て方詳細)
3. [リリース手順の記載方法（詳細）](#3-リリース手順の記載方法詳細)
4. [切り戻し方法（詳細）](#4-切り戻し方法詳細)
5. [リリース時の注意事項（詳細）](#5-リリース時の注意事項詳細)
6. [実例・ケーススタディ](#6-実例ケーススタディ)
7. [トラブルシューティング大全](#7-トラブルシューティング大全)

---

## 1. リリース計画の全体像

### 1.1 なぜリリース計画が必要なのか

> **重要な原則**: 「リリースは戦いではなく、計画的な作業である」

参照: [MoneyForward Developer Blog](https://moneyforward-dev.jp/entry/2021/12/23/release-plan/)

**リリース計画の本質**:
- 不確実性を最小化する
- **切り戻し計画が最も重要**（計画の50%は切り戻しに充てる）
- チーム全員の認識を合わせる
- リスクを事前に洗い出す

### 1.2 リリース計画のタイムライン

```mermaid
gantt
    title リリース計画タイムライン（推奨）
    dateFormat YYYY-MM-DD
    section Phase 1: 計画
    リリース計画作成開始          :done, plan1, 2025-01-01, 3d
    リスク洗い出し               :done, risk, after plan1, 2d
    切り戻し計画作成（最優先）     :active, rollback, after risk, 3d
    レビュー・承認               :review, after rollback, 2d
    section Phase 2: 準備
    リリース手順書作成            :proc, after review, 5d
    ステージングリハーサル         :rehearsal, after proc, 2d
    最終確認会議                 :meeting, after rehearsal, 1d
    section Phase 3: 実施
    本番リリース                 :milestone, release, after meeting, 1d
    section Phase 4: 事後
    監視強化期間                 :monitor, after release, 3d
    振り返り会議                 :retro, after monitor, 1d
    ドキュメント改善              :improve, after retro, 2d
```

**重要なマイルストーン**:

| タイミング | 実施内容 | 担当者 | 期限 |
|-----------|---------|--------|------|
| D-14 | リリース計画作成開始 | PM | 必須 |
| D-10 | 切り戻し計画完成 | リリース責任者 | 必須 |
| D-7 | リリース計画承認 | プロダクトオーナー | 必須 |
| D-7 | リリース手順書作成開始 | 開発チーム | 必須 |
| D-3 | ステージングリハーサル | 開発・QA | 必須 |
| D-1 | 最終確認会議（Go/No-Go判断） | 全関係者 | 必須 |
| D-Day | リリース実施 | リリース作業者 | - |
| D+3 | 振り返り会議 | 全関係者 | 推奨 |

---

## 2. リリース計画の立て方（詳細）

### 2.1 リリース計画作成の5つのステップ

#### Step 1: リリース目的の明確化（所要時間: 1時間）

**質問に答える形式で整理**:

```markdown
## なぜこのリリースが必要なのか？

### ビジネス的理由
- ユーザーから要望の多い機能を提供するため
- 競合他社と差別化するため
- セキュリティ脆弱性に対応するため

### 技術的理由
- パフォーマンス改善（レスポンスタイム50%向上）
- 技術的負債の解消
- インフラコスト削減

### 定量的な目標
- ユーザーエンゲージメント20%向上
- コンバージョン率5%向上
- エラーレート0.1%以下維持
```

#### Step 2: リリース範囲の定義（所要時間: 2時間）

**機能追加・バグ修正・技術改善を分類**:

```markdown
## リリース範囲マトリックス

| 分類 | 優先度 | チケット数 | リスク | 所要時間 |
|------|--------|-----------|--------|---------|
| 機能追加 | 高 | 5件 | 中 | 40時間 |
| バグ修正 | 高 | 3件 | 低 | 10時間 |
| 技術改善 | 中 | 2件 | 低 | 15時間 |

### 機能追加詳細

| # | 機能名 | 概要 | 依存関係 | リスク評価 | チケット |
|---|--------|------|---------|-----------|---------|
| 1 | ユーザー通知機能 | プッシュ通知・メール通知 | なし | 中（外部サービス依存） | PROJ-123 |
| 2 | ダッシュボード改善 | UIリニューアル | 機能1に依存 | 低 | PROJ-124 |
```

**リスク評価基準**:

| リスクレベル | 定義 | 対応 |
|------------|------|------|
| **高** | 主要機能への影響大、切り戻し可能性高 | 段階的リリース検討 |
| **中** | 一部機能への影響、切り戻し手順準備 | 十分なテスト実施 |
| **低** | 影響範囲限定的、問題発生確率低 | 通常のテスト実施 |

#### Step 3: 切り戻し計画の作成（所要時間: 3時間）

> **最重要**: 「切り戻し計画」がリリース計画の中で最も重要

参照: [MoneyForward Developer Blog](https://moneyforward-dev.jp/entry/2021/12/23/release-plan/)

**切り戻し計画で確認すべき事項**:

切り戻し計画を作成する際は、以下の項目が明確になっているかを確認します。まず切り戻し判断基準が明確に定義されているか、次に切り戻し手順がコピーアンドペーストで実行可能な形式になっているかを確認します。また制限時間が設定されているか(推奨は2時間以内)、データベース切り戻し手順が詳細に確認されているかも重要です。さらにステージング環境で切り戻しリハーサルを実施済みか、切り戻し後のデータ整合性確認手順が用意されているかも確認が必要です。

**切り戻し計画テンプレート**:

```markdown
## 切り戻し計画

### 制限時間
リリース開始から **2時間以内** に切り戻し判断を完了

### 切り戻し判断フロー

┌─────────────┐
│ 障害検知     │
└──────┬──────┘
       │
       ▼
  ┌─────────────┐
  │クリティカル? │ ──Yes→ 【即座に切り戻し】
  └──────┬──────┘
         No
         │
         ▼
  ┌─────────────┐
  │エラーレート  │ ──>10%→ 【切り戻し検討】
  │10倍超?      │
  └──────┬──────┘
         No
         │
         ▼
  ┌─────────────┐
  │Hotfix可能?  │ ──Yes→ 【Hotfix適用】
  └──────┬──────┘
         No
         │
         ▼
  【切り戻し実施】

### クリティカルな障害の定義
- アプリケーションが起動しない
- ログイン機能が動作しない
- 決済機能が動作しない
- データ損失が発生している
- セキュリティインシデントが発生している

### 切り戻し手順（詳細は別ドキュメント）
1. 切り戻し宣言（Slack + 電話）
2. アプリケーション切り戻し（5分）
3. データベース切り戻し（15分）
4. 動作確認（10分）
5. 完了報告

### データ整合性確認
データ整合性確認では、リリース中に登録されたデータが失われていないか、トランザクションが中断されていないか、外部サービス連携データに不整合がないかを確認します。
```

#### Step 4: リスク管理計画（所要時間: 2時間）

**リスク管理テンプレート**:

```markdown
## リスク管理マトリックス

| # | リスク内容 | 発生確率 | 影響度 | リスクスコア | 対策 | 担当者 |
|---|-----------|---------|--------|------------|------|--------|
| 1 | DBマイグレーション失敗 | 中(30%) | 高(9) | 27 | 事前リハーサル、ロールバックスクリプト | DBA |
| 2 | デプロイ中サーバーダウン | 低(10%) | 高(9) | 9 | Blue-Greenデプロイ | インフラ |
| 3 | 外部API連携エラー | 中(30%) | 中(5) | 15 | リトライ機能、タイムアウト設定 | 開発 |

**リスクスコア計算**: 発生確率(%) × 影響度(1-10)
**優先対応**: リスクスコア 20以上
```

**リスク対応の4つの戦略**:

| 戦略 | 説明 | 例 |
|------|------|-----|
| **回避** | リスクを完全に回避する | 破壊的変更を段階的リリースに分割 |
| **軽減** | リスクの影響を最小化する | 十分なテスト、リハーサル実施 |
| **転嫁** | リスクを他者に移転する | SaaS利用、保険加入 |
| **受容** | リスクを受け入れる | 影響が小さい場合、対策コスト > リスク |

#### Step 5: コミュニケーション計画（所要時間: 1時間）

```markdown
## コミュニケーション計画

### 事前告知スケジュール

| 対象 | 告知内容 | タイミング | チャネル | 担当者 |
|------|---------|-----------|---------|--------|
| 全ユーザー | メンテナンス通知 | D-3 | アプリ内通知・メール | CS |
| VIPユーザー | 個別連絡 | D-7 | 個別メール・電話 | 営業 |
| 社内関係者 | リリース詳細 | D-7 | Slack・全体会議 | PM |
| ステークホルダー | 進捗報告 | D-7, D-3, D-Day | メール | PM |

### リリース当日コミュニケーション

**Slackチャンネル**: #release-YYYYMMDD（専用チャンネル作成）

**報告頻度**: 15分ごと

**報告テンプレート**:
```
HH:MM [ステータス] 作業内容
例: 20:00 [開始] リリース作業を開始します
    20:15 [進行中] バックアップ完了（1/5）
    20:30 [完了] リリース完了
    20:30 [異常] エラーレート上昇を検知、調査中
```

### 緊急連絡体制

**エスカレーションフロー**:
```
作業者 → リリース責任者 → プロダクトオーナー → CTO → CEO
（1分）   （3分）          （5分）              （10分）
```

**連絡先リスト**（24時間対応可能）:
- リリース責任者: [氏名] [電話] [Slack]
- DBA: [氏名] [電話] [Slack]
- インフラ担当: [氏名] [電話] [Slack]
- エスカレーション先: [氏名] [電話] [Slack]
```

### 2.2 リリース計画書の構成（推奨フォーマット）

```markdown
# リリース計画書 v[X.X.X]

## 1. エグゼクティブサマリー（1ページ）
- リリース目的
- 主要な変更内容
- リリース日時
- リスク概要

## 2. リリース詳細（3-5ページ）
- リリース範囲
- スケジュール
- リリース体制
- 判断基準

## 3. 切り戻し計画（2-3ページ）
- 切り戻し判断基準
- 切り戻し手順
- データ整合性確認

## 4. リスク管理（2ページ）
- リスク一覧
- 対策
- 想定シナリオ

## 5. チェックリスト（2ページ）
- リリース前
- リリース中
- リリース後

## 6. 添付資料
- リリース手順書（別ドキュメント）
- テスト結果報告書
- データベース変更履歴
```

---

## 3. リリース手順の記載方法（詳細）

### 3.1 手順書作成の5つの原則

参照: [Agile Monster Blog](https://agile-monster.com/blog/release-manual/)

#### 原則1: 変化前・変化・変化後の確認

**すべての作業は3段階で記載**:

```markdown
### ❌ NG例（悪い手順）
1. アプリケーションをデプロイする

### ✅ OK例（良い手順）

#### 【変化前】現在のバージョン確認
```bash
# 現在のバージョンを確認
kubectl get deployment api-deployment -o jsonpath='{.spec.template.spec.containers[0].image}'
```

**期待値**: `api:v1.1.0`
**実際の値**: `______________________` （手作業で記入）

#### 【変化】新バージョンのデプロイ
```bash
# 新バージョンをデプロイ（所要時間: 約5分）
kubectl set image deployment/api-deployment api=registry.example.com/api:v1.2.0

# デプロイ状況をリアルタイム確認
kubectl rollout status deployment/api-deployment --timeout=5m
```

**目的**: 新機能を本番環境に反映するため
**注意事項**: タイムアウトした場合は即座に報告すること

#### 【変化後】新バージョン確認
```bash
# デプロイ後のバージョン確認
kubectl get deployment api-deployment -o jsonpath='{.spec.template.spec.containers[0].image}'
```

**期待値**: `registry.example.com/api:v1.2.0`
**実際の値**: `______________________`
```

#### 原則2: コピペで実行できるコマンド

**❌ NG例**:
```markdown
1. データベースに接続してマイグレーションを実行してください
```

**✅ OK例**:
```markdown
#### データベースマイグレーション実行

**所要時間**: 約10分
**目的**: 新しいテーブル `notifications` を追加するため

```bash
# 環境変数設定（本番環境）
export DATABASE_URL="postgresql://prod_user:PROD_PASSWORD@db.example.com:5432/production"
export RAILS_ENV="production"

# マイグレーション実行
bundle exec rails db:migrate

# マイグレーション結果確認
bundle exec rails db:migrate:status | tail -5
```

**期待値**: 最新のマイグレーションが `up` 状態
**実際の結果**: `______________________`
```

#### 原則3: 読者（実施者）を意識する

**実施者の状況を考慮**:
- 深夜の疲労状態
- プレッシャーを感じている
- 判断力が低下している可能性

**配慮した記載例**:

```markdown
### データベースバックアップ取得

**⚠️ 重要**: この作業を失敗すると、データ復旧ができなくなります。
慎重に実施してください。

**所要時間**: 約10分
**タイムアウト**: 15分（15分経過しても完了しない場合は報告）

**前提条件**:

作業を開始する前に、ディスク空き容量が10GB以上あることを確認します。また、データベースへの接続が正常に確立されていることも確認が必要です。

#### ステップ1: ディスク容量確認

```bash
# バックアップ保存先の容量確認
df -h /backup
```

**期待値**: 10GB以上の空き容量
**実際の値**: `______________________`

✅ もし空き容量が10GB未満の場合 → リリース責任者に報告

#### ステップ2: バックアップ取得

```bash
# バックアップファイル名（日時を含む）
BACKUP_FILE="backup_$(date +%Y%m%d_%H%M%S).dump"

# バックアップ取得（所要時間: 約8分）
pg_dump -Fc -h db.example.com -U prod_user -d production -f /backup/$BACKUP_FILE

# 完了メッセージ表示
echo "✅ バックアップ完了: $BACKUP_FILE"
echo "完了時刻: $(date)"
```

**バックアップファイル名**: `______________________` （記録）
**完了時刻**: `______________________`

#### ステップ3: バックアップ検証（必須）

```bash
# ファイルサイズ確認（0バイトでないこと）
ls -lh /backup/$BACKUP_FILE

# バックアップ内容確認（最初の20行）
pg_restore --list /backup/$BACKUP_FILE | head -20
```

**ファイルサイズ**: `______________________`
**含まれるテーブル数**: `______________________`

**❌ もしファイルサイズが0バイトまたは異常に小さい場合**:
1. Slack #release-YYYYMMDD に「バックアップ失敗」を即座に報告
2. リリース責任者に電話連絡
3. リリース中止を検討
```

#### 原則4: 相手を思いやって書く

**思いやりのある記載のポイント**:

1. **所要時間を明記する**
   ```markdown
   **所要時間**: 約10分
   ```

2. **目的を説明する**
   ```markdown
   **目的**: 万が一マイグレーションに失敗した場合に、データを復元するため
   ```

3. **注意事項を明記する**
   ```markdown
   **注意事項**: バックアップ完了まで次のステップに進まないこと
   ```

4. **判断基準を明確にする**
   ```markdown
   ✅ 正常: レスポンスタイム 3秒以内
   ⚠️ 警告: レスポンスタイム 3-5秒（監視継続）
   ❌ 異常: レスポンスタイム 5秒超（切り戻し検討）
   ```

5. **トラブル時の対応を記載する**
   ```markdown
   **❌ もしエラーが発生した場合**:
   1. エラーメッセージをコピーして Slack #release-YYYYMMDD に貼り付ける
   2. リリース責任者に電話連絡（[電話番号]）
   3. 次のステップに進まず、指示を待つ
   ```

#### 原則5: 意図を持って書く

**各作業の「なぜ」を記載**:

```markdown
### なぜデータベースバックアップが必要なのか？

**目的**: マイグレーションに失敗した場合に、データを復元するため

**リスク**: バックアップなしでマイグレーションを実行すると、
失敗時にデータを失う可能性があります。

**過去の事例**: 2024年8月のリリースで、バックアップなしで
マイグレーションを実行し、データ損失が発生しました。
この教訓から、バックアップを必須としています。

**所要時間**: 10分程度かかりますが、データを守るために
非常に重要な作業です。決してスキップしないでください。
```

### 3.2 手順書のフォーマット（推奨構造）

```markdown
# リリース手順書 v[X.X.X]

## 前提条件

リリース作業を開始する前に、以下の前提条件が満たされていることを確認します。VPN接続が完了していること、本番環境へのアクセス権限が付与されていることを確認します。また、緊急時の連絡先リストが手元にあり、いつでも連絡できる状態であることも確認します。

## リリース全体フロー
[フロー図]

所要時間目安: 約2時間

## Phase 1: 準備（30分）
### 1.1 関係者への連絡
### 1.2 現在の状態確認
### 1.3 メンテナンス告知

## Phase 2: バックアップ（20分）
### 2.1 データベースバックアップ
### 2.2 設定ファイルバックアップ

## Phase 3: デプロイ（40分）
### 3.1 イメージビルド・プッシュ
### 3.2 データベースマイグレーション
### 3.3 アプリケーションデプロイ

## Phase 4: 疎通確認（30分）
### 4.1 ヘルスチェック
### 4.2 主要機能確認
### 4.3 ログ・エラー確認

## Phase 5: 監視（24時間）
### 5.1 リリース直後の監視
### 5.2 定期監視スケジュール

## 切り戻し手順（緊急時のみ）
### 切り戻し判断基準
### 切り戻し実行手順

## トラブルシューティング
### 問題: Podが起動しない
### 問題: データベース接続エラー
```

---

## 4. 切り戻し方法（詳細）

### 4.1 切り戻し判断の3つのレベル

#### レベル1: 即座に切り戻し（議論不要）

以下の場合、**議論せず即座に切り戻し**:

```markdown
## クリティカルな障害（即座に切り戻し）

クリティカルな障害とは、アプリケーションが起動しない状況、ログイン機能が完全に動作しない状態、決済機能が完全に動作しない状態、データ損失が発生している場合、セキュリティインシデントが発生している場合、または個人情報漏洩の可能性がある場合を指します。

**判断者**: リリース責任者（単独判断可）
**判断時間**: 3分以内
**実行時間**: 即座
```

#### レベル2: 切り戻しを検討（リリース責任者判断）

```markdown
## 重大な障害（切り戻し検討）

重大な障害とは、エラーレートが通常の10倍を超えている状況、レスポンスタイムが通常の3倍を超えている状態、主要機能の一部が動作しない場合、ユーザーからのクレームが急増している状況(10件/分以上)、またはデータ整合性に問題がある場合を指します。

**判断者**: リリース責任者（関係者と協議）
**判断時間**: 10分以内
**判断基準**:
  - 制限時間内にHotfix可能か？
  - ユーザー影響の範囲は？
  - 代替手段はあるか？
```

#### レベル3: Hotfixで対応（切り戻し不要）

```markdown
## 軽微な障害（Hotfix対応）

軽微な障害とは、マイナーな機能の不具合、UIの表示崩れ、軽微なパフォーマンス劣化(正常の1.5倍程度)、またはすぐに修正可能な不具合を指します。

**対応**: Hotfixで修正
**制限時間**: 30分以内にHotfix適用
**判断**: 30分で修正できない場合は切り戻し検討
```

### 4.2 切り戻し判断フローチャート（詳細版）

```mermaid
flowchart TD
    A[障害検知] --> B{ユーザー影響あり?}
    B -->|影響なし| C[監視継続<br/>ログに記録]
    B -->|影響あり| D{クリティカル障害?<br/>ログイン/決済/データ損失/セキュリティ}

    D -->|Yes| E[【即座に切り戻し】<br/>議論不要<br/>制限時間: 3分]

    D -->|No| F{エラーレート10倍超?<br/>またはレスポンス3倍超?}

    F -->|Yes| G{制限時間内?<br/>リリース開始から2時間以内}

    G -->|制限時間超過| E

    G -->|制限時間内| H[リリース責任者判断<br/>10分以内に決定]

    F -->|No| I{Hotfix可能?<br/>30分以内に修正可能?}

    I -->|No| H

    I -->|Yes| J[Hotfix適用<br/>制限時間: 30分]

    H -->|切り戻し| E
    H -->|継続| J

    J --> K{Hotfix成功?}
    K -->|Yes| C
    K -->|No| E

    E --> L[切り戻し手順実行]
    L --> M[動作確認]
    M --> N[原因調査・再計画]

    C --> O[定期監視継続]
```

### 4.3 切り戻し手順（ステップバイステップ）

#### ステップ0: 切り戻し宣言（所要時間: 1分）

```markdown
### 切り戻し宣言

**即座に実施すること**（1分以内）:

1. **Slack通知**（最優先）
   ```
   チャンネル: #release-YYYYMMDD
   メンション: @channel @here

   【🚨 緊急 🚨 切り戻し開始】
   時刻: HH:MM
   理由: [具体的な理由を記載]
   例: エラーレート50%超、ログイン機能停止

   全員待機してください。次の指示があるまで作業を停止してください。
   ```

2. **電話連絡**（並行して実施）
   - リリース責任者: [電話番号]
   - プロダクトオーナー: [電話番号]
   - インフラ担当: [電話番号]

3. **ステータス記録**
   ```bash
   # 現在の状態をスナップショット保存
   kubectl get all -n production > /tmp/状態_$(date +%Y%m%d_%H%M%S).txt
   kubectl logs -l app=api --tail=1000 > /tmp/ログ_$(date +%Y%m%d_%H%M%S).log
   ```
```

#### ステップ1: アプリケーション切り戻し（所要時間: 5分）

```markdown
### アプリケーション切り戻し

**目的**: アプリケーションを旧バージョンに戻す
**所要時間**: 約5分
**タイムアウト**: 10分（超過時はリリース責任者に報告）

#### 1.1 現在のバージョン確認（記録用）

```bash
# 現在（切り戻し前）のバージョン
kubectl get deployment api-deployment -o jsonpath='{.spec.template.spec.containers[0].image}'
```

**現在のバージョン**: `______________________` （記録）

#### 1.2 旧バージョンに切り戻し

```bash
# 旧バージョン（v1.1.0）に切り戻し
kubectl set image deployment/api-deployment \
  api=registry.example.com/api:v1.1.0

# ロールアウト状況確認（リアルタイム）
kubectl rollout status deployment/api-deployment --timeout=5m
```

**期待値**: `deployment "api-deployment" successfully rolled out`
**実際の結果**: `______________________`

#### 1.3 Pod起動確認

```bash
# Pod状態確認
kubectl get pods -l app=api

# すべてのPodがRunning & Readyになるまで待機
kubectl wait --for=condition=Ready pod -l app=api --timeout=3m
```

**期待値**: すべてのPodが `Running` かつ `Ready 1/1`
**実際の状態**: `______________________`

#### 1.4 バージョン確認

```bash
# 切り戻し後のバージョン確認
kubectl get deployment api-deployment -o jsonpath='{.spec.template.spec.containers[0].image}'
```

**期待値**: `registry.example.com/api:v1.1.0`
**実際のバージョン**: `______________________`

**📊 進捗報告** (Slack #release-YYYYMMDD):
```
[進行中] アプリケーション切り戻し完了（1/3）
旧バージョン v1.1.0 に戻しました。
次: データベース切り戻し実施中
```
```

#### ステップ2: データベース切り戻し（所要時間: 15分）

```markdown
### データベース切り戻し

**⚠️ 超重要**: データ損失のリスクがあるため、慎重に実施してください

**所要時間**: 約15分
**タイムアウト**: 20分

#### 2.1 アプリケーション停止（データ整合性のため必須）

```bash
# アプリケーションのレプリカ数を0に設定
kubectl scale deployment/api-deployment --replicas=0

# Pod停止確認（すべて Terminating または No resources found）
kubectl get pods -l app=api
```

**期待値**: `No resources found` または すべてのPodが `Terminating`
**実際の結果**: `______________________`

⏱️ 待機: すべてのPodが完全に停止するまで待機（約30秒）

#### 2.2 現在のデータベース状態確認（記録用）

```bash
# 現在のマイグレーションバージョン確認
psql $DATABASE_URL -c "SELECT version FROM schema_migrations ORDER BY version DESC LIMIT 1;"

# 現在のテーブル一覧
psql $DATABASE_URL -c "\dt" > /tmp/tables_before_rollback.txt
```

**現在のマイグレーションバージョン**: `______________________`

#### 2.3 バックアップから復元

**⚠️ 注意**: リリース開始時に取得したバックアップファイルを使用

```bash
# バックアップファイル確認
BACKUP_FILE="/backup/backup_20250125_200000.dump"  # リリース時に取得したファイル名
ls -lh $BACKUP_FILE

# ファイルサイズ確認（0バイトでないこと）
if [ ! -s "$BACKUP_FILE" ]; then
  echo "❌ ERROR: バックアップファイルが空です"
  echo "リリース責任者に即座に報告してください"
  exit 1
fi

echo "✅ バックアップファイル確認OK"
```

**バックアップファイルサイズ**: `______________________`

```bash
# データベース復元（所要時間: 約10分）
# ⚠️ この操作は既存データを上書きします
pg_restore -d production --clean --if-exists $BACKUP_FILE

# 復元結果確認
if [ $? -eq 0 ]; then
  echo "✅ データベース復元完了"
else
  echo "❌ ERROR: データベース復元失敗"
  echo "リリース責任者に即座に報告してください"
  exit 1
fi
```

**復元結果**: `______________________`

#### 2.4 マイグレーションロールバック

```bash
# マイグレーションを1ステップ戻す
kubectl run migration-rollback --image=registry.example.com/api:v1.1.0 \
  --restart=Never \
  --env="DATABASE_URL=$DATABASE_URL" \
  --command -- bundle exec rails db:rollback STEP=1

# ログ確認
kubectl logs migration-rollback -f
```

**期待値**: `Reverted [マイグレーション名]`
**実際の結果**: `______________________`

#### 2.5 データベース状態確認

```bash
# ロールバック後のマイグレーションバージョン確認
psql $DATABASE_URL -c "SELECT version FROM schema_migrations ORDER BY version DESC LIMIT 1;"

# テーブル一覧確認
psql $DATABASE_URL -c "\dt"
```

**ロールバック後のバージョン**: `______________________`

#### 2.6 アプリケーション再起動

```bash
# レプリカ数を元に戻す（通常は3）
kubectl scale deployment/api-deployment --replicas=3

# Pod起動確認
kubectl wait --for=condition=Ready pod -l app=api --timeout=3m
```

**📊 進捗報告** (Slack #release-YYYYMMDD):
```
[進行中] データベース切り戻し完了（2/3）
バックアップから復元し、マイグレーションをロールバックしました。
次: 動作確認実施中
```
```

#### ステップ3: 動作確認（所要時間: 10分）

```markdown
### 動作確認

**目的**: 切り戻しが正常に完了し、サービスが正常稼働していることを確認

#### 3.1 ヘルスチェック

```bash
# ヘルスチェックエンドポイント確認
curl -f https://api.example.com/health

# レスポンスタイム確認
time curl https://api.example.com/health
```

**期待値**:
- HTTPステータス: 200
- レスポンス: `{"status":"ok"}`
- レスポンスタイム: 3秒以内

**実際の結果**: `______________________`
**レスポンスタイム**: `______________________`

#### 3.2 ログイン機能確認

```bash
# ログインAPIテスト
curl -X POST https://api.example.com/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"test123"}'
```

**期待値**: JWTトークンが返却される
**実際の結果**: `______________________`

#### 3.3 主要API確認

```bash
# ユーザー情報取得APIテスト（ログインで取得したトークンを使用）
curl -H "Authorization: Bearer <TOKEN>" \
  https://api.example.com/users/1
```

**期待値**: ユーザー情報が正常に返却される
**実際の結果**: `______________________`

#### 3.4 エラーログ確認

```bash
# 直近100行のエラーログ確認
kubectl logs -l app=api --tail=100 | grep -i error

# エラー件数カウント
kubectl logs -l app=api --tail=1000 | grep -i error | wc -l
```

**期待値**: クリティカルなエラーがないこと
**エラー件数**: `______________________`

#### 3.5 データ整合性確認

```bash
# リリース中に登録されたデータの確認（該当する場合）
psql $DATABASE_URL -c "SELECT COUNT(*) FROM users WHERE created_at > '2025-01-25 20:00:00';"

# 外部サービス連携データの確認（該当する場合）
# （具体的な確認方法はプロジェクトに応じて記載）
```

**確認結果**: `______________________`

**📊 進捗報告** (Slack #release-YYYYMMDD):
```
[完了] 動作確認完了（3/3）
すべての主要機能が正常に動作していることを確認しました。
次: 完了報告
```
```

#### ステップ4: 完了報告（所要時間: 5分）

```markdown
### 切り戻し完了報告

#### 4.1 Slack報告

```
チャンネル: #release-YYYYMMDD
メンション: @channel

【✅ 切り戻し完了】
完了時刻: HH:MM
切り戻し所要時間: XX分
状態: 旧バージョン v1.1.0 で正常稼働中

確認完了項目:
✅ ヘルスチェック正常
✅ ログイン機能正常
✅ 主要API正常
✅ エラーログ正常範囲内

次のアクション:
- 監視継続（24時間）
- 原因調査実施
- 再リリース計画策定
```

#### 4.2 メール報告（ステークホルダー向け）

```
件名: [重要] リリースv1.2.0 切り戻し完了のご報告

本日実施したリリースv1.2.0について、以下の理由により
切り戻しを実施いたしました。

■ 切り戻し理由
[具体的な理由]

■ 影響範囲
- 影響時間: HH:MM ~ HH:MM（XX分間）
- 影響ユーザー数: 推定XX名
- データ損失: なし

■ 現在の状況
旧バージョンv1.1.0で正常稼働中

■ 今後の対応
1. 原因調査実施（担当: XX、期限: XX日）
2. 再リリース計画策定（担当: XX、期限: XX日）

ご心配をおかけし申し訳ございません。
```

#### 4.3 ユーザー向け通知（該当する場合）

```
【メンテナンス完了のお知らせ】

本日実施しておりましたメンテナンスが完了いたしました。

現在、サービスは正常にご利用いただけます。

ご不便をおかけいたしまして、誠に申し訳ございませんでした。
```
```

### 4.4 切り戻し後の監視（24時間）

```markdown
## 切り戻し後の監視計画

### 監視強化期間: 24時間

| 時刻 | 確認項目 | 担当者 | 完了 |
|------|---------|--------|------|
| 切り戻し直後 | エラーレート・レスポンスタイム | 作業者 | [ ] |
| +30分 | 同上 + ユーザー問い合わせ | 作業者 | [ ] |
| +1時間 | 同上 | 作業者 | [ ] |
| +3時間 | 同上 | オンコール | [ ] |
| +6時間 | 同上 | オンコール | [ ] |
| +12時間 | 同上 | オンコール | [ ] |
| +24時間 | 同上 + データ整合性 | オンコール | [ ] |

### 監視項目

| 指標 | 正常範囲 | 警告閾値 | 異常閾値 |
|------|---------|---------|---------|
| エラーレート | 0.1%以下 | 0.5% | 1.0% |
| レスポンスタイム(p95) | 1.5秒以内 | 3秒 | 5秒 |
| CPU使用率 | 50%以下 | 70% | 80% |
| メモリ使用率 | 60%以下 | 75% | 85% |
```

---

## 5. リリース時の注意事項（詳細）

### 5.1 リリース前の心構え（精神論）

参照: [Agile Monster Blog](https://agile-monster.com/blog/release-manual/)

#### 心構え1: リリースは「戦い」ではなく「計画的な作業」

❌ **誤った考え方**:
- 「リリースは何が起こるか分からない」
- 「とりあえずやってみよう」
- 「問題が起きたらそのとき考えよう」

✅ **正しい考え方**:
- 「リリースは計画に基づいて実施する作業」
- 「想定されるリスクはすべて洗い出し、対策を準備している」
- 「切り戻し手順を確認済みで、いつでも戻せる」

#### 心構え2: 「思考停止でもリリースが完了する」レベルを目指す

**理由**: リリース当日は緊張や疲労で判断力が低下する

**対策**:
- すべてのコマンドがコピペで実行可能
- すべての判断基準がYes/No明確
- すべてのエスカレーションフローが明確

**例**:

❌ **NG**: 「適宜判断してください」
✅ **OK**:
```
エラーレート10%超 → 即座にリリース責任者に電話
レスポンスタイム5秒超 → 切り戻し実施
```

#### 心構え3: 「失敗しても大丈夫」な準備をする

**確認事項**:

失敗しても大丈夫な状態にするために、以下の準備が整っていることを確認します。バックアップが確実に取得されていること、そのバックアップが検証されていることを確認します。また、切り戻し手順が明確に確認されていること、ステージング環境で切り戻しリハーサルを実施済みであることも必要です。さらに、制限時間内に確実に切り戻せる自信があることを確認します。

### 5.2 データベース変更時の注意事項（詳細）

#### 破壊的変更を避ける原則

**破壊的変更の定義**:
- カラムの削除
- テーブルの削除
- データ型の変更（文字列→数値等）
- NOT NULL制約の追加（既存データがNULLの場合）
- ユニーク制約の追加（重複データがある場合）

**段階的リリースパターン**（推奨）:

```markdown
## 段階的リリースパターン: カラム名変更の例

### 従来（破壊的変更）
❌ リリース1回で `email` → `email_address` に変更
→ 切り戻し時にデータ損失のリスク

### 推奨（段階的リリース）

#### Phase 1: 新カラム追加（リリースv1.2.0）
```sql
-- 新カラム追加（NULL許可）
ALTER TABLE users ADD COLUMN email_address VARCHAR(255);

-- 既存データをコピー
UPDATE users SET email_address = email WHERE email_address IS NULL;
```

**アプリケーション変更**:
- 新旧両カラムに書き込み
- 読み込みは旧カラム優先

**切り戻し**: 新カラムを削除するだけ（データ損失なし）

#### Phase 2: 読み込み切り替え（リリースv1.3.0）
**アプリケーション変更**:
- 新旧両カラムに書き込み
- 読み込みは新カラム優先

**検証**: 2週間運用して問題ないことを確認

**切り戻し**: 読み込みを旧カラムに戻すだけ

#### Phase 3: 旧カラム削除（リリースv1.4.0）
```sql
-- 旧カラム削除
ALTER TABLE users DROP COLUMN email;
```

**アプリケーション変更**:
- 新カラムのみ使用

**検証**: 問題なければ完了
```

#### 大量データ変更のベストプラクティス

**❌ NG**: 一括更新（ロック時間長い）

```sql
-- 100万件を一度に更新（数分ロック）
UPDATE users SET status = 'active' WHERE status IS NULL;
```

**✅ OK**: バッチ更新（ロック時間短い）

```sql
-- 1000件ずつ更新（各バッチは数秒）
DO $$
DECLARE
  batch_size INT := 1000;
  affected_rows INT;
  total_updated INT := 0;
BEGIN
  LOOP
    UPDATE users
    SET status = 'active'
    WHERE id IN (
      SELECT id FROM users
      WHERE status IS NULL
      LIMIT batch_size
    );

    GET DIAGNOSTICS affected_rows = ROW_COUNT;
    total_updated := total_updated + affected_rows;

    RAISE NOTICE 'Updated % rows (total: %)', affected_rows, total_updated;

    EXIT WHEN affected_rows = 0;

    -- 他のトランザクションを待たせないため
    COMMIT;

    -- 負荷分散のため（本番環境の状況に応じて調整）
    PERFORM pg_sleep(0.1);  -- 100ミリ秒待機
  END LOOP;

  RAISE NOTICE 'Total updated: % rows', total_updated;
END $$;
```

### 5.3 監視・ログ確認のポイント（詳細）

#### リリース後の監視チェックリスト（時系列）

**リリース直後（0-5分）**:

```markdown
## リリース直後の確認（最重要）

### ヘルスチェック
```bash
# APIヘルスチェック（10秒ごとに5回実行）
for i in {1..5}; do
  echo "=== Check $i/5 ==="
  curl -f https://api.example.com/health
  echo ""
  sleep 10
done
```

✅ 期待値: すべて成功（HTTP 200）

### エラーログ確認
```bash
# 直近100行のエラーログ
kubectl logs -l app=api --tail=100 | grep -i error

# エラー件数
kubectl logs -l app=api --tail=1000 | grep -i error | wc -l
```

✅ 期待値: クリティカルなエラーなし、エラー件数 10件以下

### レスポンスタイム確認
```bash
# レスポンスタイム測定（10回平均）
for i in {1..10}; do
  time curl -s https://api.example.com/users/1 > /dev/null
done
```

✅ 期待値: 平均3秒以内

### リソース使用率確認
```bash
# Pod のCPU・メモリ使用率
kubectl top pods -l app=api
```

✅ 期待値: CPU 80%以下、メモリ 80%以下
```

**15分後**:

```markdown
## 15分後の確認

### エラーレート確認（ダッシュボード）
- URL: https://monitoring.example.com/errors
- 確認項目: エラーレートのグラフ

✅ 期待値: 通常と同程度（0.1%以下）
⚠️ 警告: 0.5%以上（調査開始）
❌ 異常: 1.0%以上（切り戻し検討）

### レスポンスタイム確認（ダッシュボード）
- URL: https://monitoring.example.com/latency
- 確認項目: p50, p95, p99

✅ 期待値:
  - p50: 1秒以内
  - p95: 3秒以内
  - p99: 5秒以内

### ユーザー影響確認
- カスタマーサポートへの問い合わせ件数
- Twitterでのエラー報告
- アプリストアレビュー

✅ 期待値: 通常と同程度
```

**1時間後**:

```markdown
## 1時間後の確認

### データベース接続数
```bash
psql $DATABASE_URL -c "SELECT count(*) FROM pg_stat_activity WHERE state = 'active';"
```

✅ 期待値: 通常と同程度

### バッチ処理確認（該当する場合）
- 定時バッチが正常実行されているか
- ジョブキューに滞留がないか

✅ 期待値: すべて正常実行
```

**24時間後**:

```markdown
## 24時間後の確認

### 日次バッチ処理確認
- 深夜バッチが正常実行されたか
- レポート生成が成功したか

### データ整合性確認
- トランザクションログの確認
- データ不整合の確認
- 外部サービス連携データの確認

### パフォーマンス指標
- エラーレート24時間平均
- レスポンスタイム24時間平均
- ユーザー問い合わせ件数

✅ すべて正常なら監視強化期間終了
```

---

## 6. 実例・ケーススタディ

### 6.1 成功事例: 段階的リリースでリスクを最小化

**プロジェクト**: ECサイトの決済機能リニューアル

**状況**:
- 決済プロバイダーを変更（A社 → B社）
- 月間取引額10億円の重要機能
- 失敗時の影響が極めて大きい

**採用した戦略**: 段階的リリース（カナリアリリース）

```markdown
## 段階的リリース計画

### Phase 1: 内部テスト（Week 1）
- 対象: 社員アカウントのみ（10人）
- 期間: 1週間
- 目的: 基本動作確認

### Phase 2: ベータテスト（Week 2）
- 対象: ベータテスター（100人）
- 期間: 1週間
- 目的: 実データでの動作確認

### Phase 3: カナリアリリース（Week 3）
- 対象: 全ユーザーの1%（1000人）
- 期間: 3日間
- 目的: 本番環境での安定性確認

### Phase 4: 段階的拡大（Week 4）
- Day 1: 10%
- Day 2: 25%
- Day 3: 50%
- Day 4: 100%

### 判断基準（各フェーズ）
- エラーレート: 0.1%以下
- 決済成功率: 99.9%以上
- ユーザークレーム: 0件
```

**結果**:
- Phase 3で軽微なバグを発見（1%ユーザーのみ影響）
- 即座に修正して再デプロイ
- Phase 4を1週間延期して慎重に実施
- 最終的に無事故で完全移行達成

**教訓**:
- 重要機能は段階的リリースが必須
- 各フェーズの判断基準を明確にする
- 問題発生時は躊躇なく延期する

### 6.2 失敗事例: バックアップ未検証で復旧不可

**プロジェクト**: SaaSアプリケーションの大規模アップデート

**状況**:
- データベーススキーマ変更（20テーブル追加）
- バックアップ取得済み（と思っていた）
- 深夜にリリース実施

**何が起きたか**:

1. **リリース開始** (22:00)
   - バックアップ取得（と思っていた）
   - マイグレーション実行

2. **問題発生** (22:30)
   - マイグレーションが途中で失敗
   - データベースが不整合状態

3. **切り戻し試行** (22:35)
   - バックアップから復元を試みる
   - **バックアップファイルが0バイト！**
   - ディスク容量不足でバックアップ失敗していた

4. **パニック** (22:40)
   - 復元不可能
   - データベースが破損状態
   - サービス停止

**復旧までの経緯**:
- レプリケーションスレーブDBから手動復旧（4時間）
- マイグレーション失敗部分を手動修正（2時間）
- 合計6時間のサービス停止

**失敗の原因**:

1. **バックアップの未検証**
   ```bash
   # ❌ 実施していたこと（NG）
   pg_dump production > backup.dump
   # ファイルサイズ確認なし！
   ```

   ```bash
   # ✅ 実施すべきだったこと（OK）
   pg_dump production > backup.dump

   # ファイルサイズ確認
   ls -lh backup.dump

   # 内容確認
   pg_restore --list backup.dump | head -20

   # （理想）テスト環境で復元テスト
   ```

2. **ディスク容量の未確認**
   ```bash
   # ✅ 実施すべきだったこと
   df -h /backup  # 空き容量確認
   ```

3. **バックアップ取得の未監視**
   - バックアップコマンドのexit code確認なし
   - エラー出力の確認なし

**改善策**:

```markdown
## バックアップ手順（改善版）

### 事前確認
```bash
# ディスク容量確認（バックアップサイズの2倍以上必要）
df -h /backup
```

### バックアップ取得
```bash
BACKUP_FILE="backup_$(date +%Y%m%d_%H%M%S).dump"

# バックアップ取得（エラー検知付き）
pg_dump -Fc production -f /backup/$BACKUP_FILE

# exit code確認
if [ $? -ne 0 ]; then
  echo "❌ ERROR: バックアップ失敗"
  exit 1
fi
```

### バックアップ検証（必須）
```bash
# 1. ファイルサイズ確認
FILE_SIZE=$(stat -f%z "/backup/$BACKUP_FILE" 2>/dev/null || stat -c%s "/backup/$BACKUP_FILE")

if [ "$FILE_SIZE" -lt 1000000 ]; then  # 1MB未満なら異常
  echo "❌ ERROR: バックアップファイルが小さすぎます（${FILE_SIZE}バイト）"
  exit 1
fi

# 2. 内容確認
pg_restore --list /backup/$BACKUP_FILE > /tmp/backup_list.txt

TABLE_COUNT=$(grep "TABLE DATA" /tmp/backup_list.txt | wc -l)

if [ "$TABLE_COUNT" -lt 10 ]; then  # 想定より少ない
  echo "❌ ERROR: テーブル数が少なすぎます（${TABLE_COUNT}テーブル）"
  exit 1
fi

# 3. （可能なら）テスト環境で復元テスト
pg_restore -d test_db --clean /backup/$BACKUP_FILE
```

### 確認事項

バックアップ作業完了後、以下の項目を確認します。ディスク容量が十分にあること、バックアップ取得が成功していること（exit code 0）、ファイルサイズが正常であること（1MB以上）、テーブル数が正常であること（10以上）を確認します。理想的には、テスト環境でバックアップからの復元が成功することも確認します。
```

**教訓**:
- バックアップ取得は「取るだけ」では不十分
- 必ず検証する
- 可能ならテスト環境で復元テストする
- ディスク容量は事前に確認する

### 6.3 失敗事例: 切り戻し制限時間超過でさらなる混乱

**プロジェクト**: モバイルアプリのバックエンドAPI更新

**状況**:
- APIのバージョンアップ（v1 → v2）
- 互換性のない変更（破壊的変更）
- リリース計画では「問題あれば切り戻し」と記載

**何が起きたか**:

1. **リリース開始** (21:00)
   - v2 APIをデプロイ

2. **問題発生** (21:15)
   - 一部のモバイルアプリ（古いバージョン）が動作しない
   - エラーレート30%

3. **切り戻し決定** (21:20)
   - 「切り戻そう」と判断

4. **切り戻し試行** (21:25)
   - v1 APIに切り戻し開始
   - **データベーススキーマがv2専用に変更されていた**
   - v1 APIが起動しない

5. **混乱** (21:40)
   - v1に戻せない、v2も不安定
   - どうしたらいいか分からない
   - **切り戻し手順が不明確**

6. **最悪の選択** (22:00)
   - 「とりあえずv2で動くように緊急修正しよう」
   - 深夜の緊急開発開始

7. **復旧** (翌朝6:00)
   - 9時間後にようやく安定化
   - 合計9時間のサービス不安定

**失敗の原因**:

1. **切り戻し手順の未確認**
   - 「切り戻せる」と思い込んでいた
   - 実際には破壊的変更があり切り戻し不可能

2. **制限時間の未設定**
   - 「いつまでに切り戻すか」が決まっていなかった
   - ズルズルと時間が経過

3. **互換性の未考慮**
   - 新旧バージョンの互換性を考慮していなかった
   - 段階的移行を検討していなかった

**改善策**:

```markdown
## 破壊的変更のリリース計画（改善版）

### 原則: 破壊的変更は段階的に実施

#### Phase 1: v1 と v2 の並行稼働（Week 1）
```yaml
# API Gateway設定
/api/v1/* → v1 API
/api/v2/* → v2 API（新規）
```

- 既存ユーザー: v1 API使用継続
- 新規ユーザー: v2 API使用
- 切り戻し: v2 APIを停止するだけ（v1は影響なし）

#### Phase 2: ユーザーの段階的移行（Week 2-4）
- Week 2: 10%のユーザーをv2に移行
- Week 3: 50%のユーザーをv2に移行
- Week 4: 100%のユーザーをv2に移行

#### Phase 3: v1 API廃止（Week 5-）
- すべてのユーザーがv2に移行完了後
- v1 APIを段階的に縮小
- 最終的に完全廃止

### 切り戻し計画（各フェーズ）

#### Phase 1の切り戻し
```bash
# v2 APIを停止するだけ
kubectl scale deployment/api-v2 --replicas=0
```

**所要時間**: 1分
**データ損失**: なし（v1のデータベースを使用）

#### Phase 2の切り戻し（10%移行時）
```bash
# v2に移行したユーザーをv1に戻す
# Feature Flagで切り替え
update users set api_version = 'v1' where api_version = 'v2'
```

**所要時間**: 5分
**影響範囲**: 移行済みユーザーのみ（10%）

### 制限時間の設定

| フェーズ | 制限時間 | 判断者 |
|---------|---------|--------|
| Phase 1 | 問題発生から10分以内 | リリース責任者 |
| Phase 2 | 問題発生から30分以内 | プロダクトオーナー |
```

**教訓**:
- 破壊的変更は段階的に実施する
- 新旧バージョンを並行稼働させる
- 切り戻し制限時間を明確に設定する
- 切り戻し手順を事前にリハーサルする

---

## 7. トラブルシューティング大全

### 7.1 よくある問題と解決方法（カテゴリ別）

#### カテゴリA: データベース関連

**問題A-1: マイグレーションがタイムアウトする**

**症状**:
```
ActiveRecord::StatementTimeout: PG::QueryCanceled: ERROR: canceling statement due to statement timeout
```

**原因**: 大量データへのロック取得

**解決方法**:

```sql
-- ❌ NG: ロック取得（タイムアウトする）
ALTER TABLE users ADD COLUMN status VARCHAR(20) DEFAULT 'active' NOT NULL;

-- ✅ OK: 段階的に実施
-- Step 1: カラム追加（NULL許可、DEFAULT値なし）
ALTER TABLE users ADD COLUMN status VARCHAR(20);

-- Step 2: 既存データを少しずつ更新（ロック時間短い）
UPDATE users SET status = 'active'
WHERE id IN (SELECT id FROM users WHERE status IS NULL LIMIT 1000);
-- これを繰り返し

-- Step 3: NOT NULL制約追加（データが埋まった後）
ALTER TABLE users ALTER COLUMN status SET NOT NULL;
```

**問題A-2: データベース接続数上限エラー**

**症状**:
```
FATAL: remaining connection slots are reserved for non-replication superuser connections
```

**原因**: コネクションプールの設定ミス、またはコネクションリーク

**解決方法**:

```bash
# 1. 現在の接続数確認
psql $DATABASE_URL -c "
SELECT
  count(*) as total_connections,
  count(*) FILTER (WHERE state = 'active') as active,
  count(*) FILTER (WHERE state = 'idle') as idle
FROM pg_stat_activity;
"

# 2. 接続元ごとの接続数確認
psql $DATABASE_URL -c "
SELECT application_name, count(*)
FROM pg_stat_activity
GROUP BY application_name;
"

# 3. 長時間アイドル接続のKill（緊急時）
psql $DATABASE_URL -c "
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE state = 'idle'
  AND state_change < NOW() - INTERVAL '10 minutes';
"

# 4. アプリケーションのコネクションプール設定確認
# config/database.yml (Rails例)
pool: 5  # 1Pod あたり5接続まで
timeout: 5000
```

**問題A-3: デッドロック発生**

**症状**:
```
PG::DeadlockDetected: ERROR: deadlock detected
```

**原因**: 複数のトランザクションが相互にロック待ち

**解決方法**:

```sql
-- 1. デッドロック検出
SELECT
  pid,
  state,
  query,
  wait_event_type
FROM pg_stat_activity
WHERE wait_event_type = 'Lock';

-- 2. ロック情報詳細
SELECT
  l.relation::regclass,
  l.mode,
  a.query
FROM pg_locks l
JOIN pg_stat_activity a ON a.pid = l.pid
WHERE NOT l.granted;

-- 3. 予防策: トランザクション順序を統一
-- ❌ NG
BEGIN;
UPDATE table_a WHERE id = 1;
UPDATE table_b WHERE id = 1;
COMMIT;

-- 別のトランザクション
BEGIN;
UPDATE table_b WHERE id = 1;  -- 逆順！
UPDATE table_a WHERE id = 1;
COMMIT;

-- ✅ OK: 順序を統一
-- 常に table_a → table_b の順でロック取得
```

#### カテゴリB: デプロイ関連

**問題B-1: Podが起動しない（CrashLoopBackOff）**

**症状**:
```bash
kubectl get pods
NAME                   READY   STATUS             RESTARTS
api-xxx                0/1     CrashLoopBackOff   5
```

**原因調査**:

```bash
# 1. Pod詳細確認
kubectl describe pod api-xxx

# 2. ログ確認（クラッシュ前のログ）
kubectl logs api-xxx --previous

# 3. イベント確認
kubectl get events --sort-by='.lastTimestamp' | tail -20
```

**よくある原因と解決方法**:

```markdown
### 原因1: 環境変数未設定

**ログ**:
```
Error: DATABASE_URL is required
```

**解決**:
```bash
# ConfigMap/Secret確認
kubectl get configmap app-config -o yaml
kubectl get secret app-secret -o yaml

# 環境変数設定
kubectl set env deployment/api DATABASE_URL="postgresql://..."
```

### 原因2: ヘルスチェック失敗

**ログ**:
```
Liveness probe failed: HTTP probe failed with statuscode: 500
```

**解決**:
```bash
# ヘルスチェックエンドポイント確認
kubectl port-forward api-xxx 8080:8080
curl http://localhost:8080/health

# デプロイメント設定確認
kubectl get deployment api -o yaml | grep -A 10 livenessProbe
```

### 原因3: イメージPullエラー

**症状**:
```
Failed to pull image "registry.example.com/api:v1.2.0": rpc error: code = Unknown
```

**解決**:
```bash
# イメージ存在確認
docker pull registry.example.com/api:v1.2.0

# レジストリ認証確認
kubectl get secret regcred -o yaml
```
```

**問題B-2: ローリングアップデート中にダウンタイム発生**

**原因**: Graceful Shutdownの未実装

**解決方法**:

```yaml
# deployment.yaml
spec:
  template:
    spec:
      containers:
      - name: api
        # Graceful shutdown設定
        lifecycle:
          preStop:
            exec:
              command: ["/bin/sh", "-c", "sleep 15"]  # 15秒待機

        # ヘルスチェック設定
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
          failureThreshold: 3

        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          failureThreshold: 3

      # Graceful shutdown期間
      terminationGracePeriodSeconds: 30
```

```ruby
# アプリケーション側（Rails例）
# config/puma.rb
on_worker_shutdown do
  # 新しいリクエストを受け付けない
  # 既存リクエストは完了まで待つ
end
```

#### カテゴリC: パフォーマンス関連

**問題C-1: リリース後にレスポンスタイムが3倍に増加**

**原因調査手順**:

```bash
# 1. APMツールで遅いエンドポイント特定
# (Datadog, New Relic等のダッシュボード確認)

# 2. データベーススロークエリ確認
psql $DATABASE_URL -c "
SELECT
  query,
  calls,
  mean_exec_time,
  max_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 10;
"

# 3. インデックス不足確認
psql $DATABASE_URL -c "
SELECT
  schemaname,
  tablename,
  seq_scan,
  seq_tup_read,
  idx_scan,
  seq_tup_read / seq_scan as avg_seq_tup
FROM pg_stat_user_tables
WHERE seq_scan > 0
ORDER BY seq_tup_read DESC
LIMIT 10;
"
```

**よくある原因と解決**:

```markdown
### 原因1: インデックス不足

**症状**: `seq_scan` が多い

**解決**:
```sql
-- 新しいクエリにインデックス追加
CREATE INDEX CONCURRENTLY idx_users_status ON users(status);
```

**注意**: `CONCURRENTLY` を付けないとテーブルロック発生！

### 原因2: N+1クエリ

**症状**: クエリ数が異常に多い

**解決**:
```ruby
# ❌ NG
User.all.each do |user|
  puts user.posts.count  # N+1発生
end

# ✅ OK
User.includes(:posts).each do |user|
  puts user.posts.count  # 1クエリ
end
```

### 原因3: キャッシュ無効化

**症状**: リリース後にキャッシュがクリアされた

**解決**:
```bash
# キャッシュウォームアップスクリプト実行
ruby scripts/cache_warmup.rb
```
```

**問題C-2: メモリリーク**

**症状**:
- メモリ使用量が時間とともに増加
- 最終的にPodが再起動される

**原因調査**:

```bash
# 1. メモリ使用量推移確認
kubectl top pod api-xxx --containers

# 2. メモリプロファイリング（Ruby例）
# Gemfileに追加
gem 'memory_profiler'

# コード
require 'memory_profiler'
report = MemoryProfiler.report do
  # 疑わしいコード
end
report.pretty_print
```

**よくある原因**:
- グローバル変数へのオブジェクト蓄積
- キャッシュの無限増殖
- ファイルハンドルのリーク

#### カテゴリD: 外部サービス連携

**問題D-1: 外部APIがタイムアウトする**

**症状**:
```
Net::ReadTimeout: execution expired
```

**解決方法**:

```ruby
# ❌ NG: タイムアウト設定なし
response = HTTP.get("https://external-api.example.com/data")

# ✅ OK: タイムアウト・リトライ設定
require 'httparty'

options = {
  timeout: 5,  # 5秒でタイムアウト
  headers: { 'User-Agent' => 'MyApp/1.0' }
}

# リトライ機能付き
retries = 0
begin
  response = HTTParty.get("https://external-api.example.com/data", options)
rescue Net::ReadTimeout => e
  retries += 1
  if retries < 3
    sleep(1 * retries)  # 指数バックオフ
    retry
  else
    # フォールバック処理
    logger.error("External API timeout after 3 retries: #{e}")
    return default_response
  end
end
```

**問題D-2: 決済API連携エラー**

**症状**: リリース後に決済が失敗する

**緊急対応**:

```markdown
## 決済エラー緊急対応フロー

### Step 1: 即座に確認（1分）
```bash
# 決済API疎通確認
curl https://payment-api.example.com/health
```

### Step 2: エラーログ確認（3分）
```bash
# 決済関連エラーログ抽出
kubectl logs -l app=api --tail=1000 | grep -i payment > payment_errors.log
```

### Step 3: 判断（5分以内）

**エラーレート > 10%** → 即座に切り戻し
**エラーレート < 10%** → 原因調査継続

### Step 4: 暫定対応（該当する場合）
- 決済方法を一時的に制限（クレジットカードのみ等）
- ユーザーにエラーメッセージ表示
- 代替決済手段の案内
```

---

## まとめ

### リリース成功の10の鉄則

1. **切り戻し計画を最優先で作成する**
   - リリース計画の50%は切り戻しに充てる

2. **変化前・変化・変化後を必ず確認する**
   - すべての作業は3段階で記載

3. **コピペで実行できるコマンドを記載する**
   - 思考停止でもリリースが完了するレベル

4. **制限時間を設定する**
   - 推奨: リリース開始から2時間以内に切り戻し判断

5. **バックアップは取得だけでなく検証する**
   - ファイルサイズ確認、内容確認、復元テスト

6. **破壊的変更は段階的に実施する**
   - 新旧バージョンを並行稼働させる

7. **ステージング環境でリハーサルする**
   - 切り戻しを含む全手順を実施

8. **15分ごとに進捗報告する**
   - Slackで関係者全員に共有

9. **リリース後24時間は監視を強化する**
   - 定期的にメトリクス確認

10. **振り返りを必ず実施し、ドキュメントを改善する**
    - Keep/Problem/Tryで整理

---

**最終更新日**: 2025年12月
**ドキュメントバージョン**: 1.0
**作成者**: 開発チーム
